/*

Copyright (c) Oscar Sebio Cajaraville 2019. 

*/

#ifndef _HIDUSBFX2_H_
#define _HIDUSBFX2_H_

#pragma warning(disable:4200)  // suppress nameless struct/union warning
#pragma warning(disable:4201)  // suppress nameless struct/union warning
#pragma warning(disable:4214)  // suppress bit field types other than int warning
#include <initguid.h>
#include <wdm.h>
#include "usbdi.h"
#include "usbdlib.h"

#pragma warning(default:4200)
#pragma warning(default:4201)
#pragma warning(default:4214)
#include <wdf.h>
#include "wdfusb.h"

#pragma warning(disable:4201)  // suppress nameless struct/union warning
#pragma warning(disable:4214)  // suppress bit field types other than int warning
#include <hidport.h>

#define NTSTRSAFE_LIB
#include <ntstrsafe.h>

#include "trace.h"

#define _DRIVER_NAME_                 "STEEL BATTALION CONTROLLER: "
#define POOL_TAG                      (ULONG) 'HSBC'

#define INTERRUPT_ENDPOINT_INDEX     (0)

typedef UCHAR HID_REPORT_DESCRIPTOR, *PHID_REPORT_DESCRIPTOR;

//
// This is the default report descriptor for the Hid device provided
// by the mini driver in response to IOCTL_HID_GET_REPORT_DESCRIPTOR.
// 
// AC: Aplication Control
// AL: Application Launch

#ifdef USE_HARDCODED_HID_REPORT_DESCRIPTOR


//
// HID Report Descriptor
//
CONST HID_REPORT_DESCRIPTOR G_DefaultReportDescriptor[] = {
	0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
	0x09, 0x05,                    // USAGE (Game Pad)
	0xa1, 0x01,                    // COLLECTION (Application)
	0x75, 0x01,                    //   REPORT_SIZE (1)
	0x95, 0x27,                    //   REPORT_COUNT (39)
	0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
	0x25, 0x01,                    //   LOGICAL_MAXIMUM (1)
	0x05, 0x09,                    //   USAGE_PAGE (Button)
	0x19, 0x01,                    //   USAGE_MINIMUM (Button 1)
	0x29, 0x27,                    //   USAGE_MAXIMUM (Button 39)
	0x81, 0x02,                    //   INPUT (Data,Var,Abs)
	0x75, 0x01,                    //   REPORT_SIZE (1)
	0x95, 0x01,                    //   REPORT_COUNT (1)
	0x81, 0x03,                    //   INPUT (Cnst,Var,Abs)
	0x05, 0x01,                    //   USAGE_PAGE (Generic Desktop)
	0x09, 0x01,                    //   USAGE (Pointer)
	0xa1, 0x00,                    //   COLLECTION (Physical)
	0x09, 0x30,                    //     USAGE (X)
	0x09, 0x31,                    //     USAGE (Y)
	0x09, 0x32,                    //     USAGE (Z)
	0x09, 0x33,                    //     USAGE (Rx)
	0x09, 0x34,                    //     USAGE (Ry)
	0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
	0x26, 0xff, 0x00,              //     LOGICAL_MAXIMUM (255)
	0x75, 0x08,                    //     REPORT_SIZE (8)
	0x95, 0x05,                    //     REPORT_COUNT (5)
	0x81, 0x02,                    //     INPUT (Data,Var,Abs)
	0xc0,                          //   END_COLLECTION
	0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
	0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
	0x05, 0x01,                    //   USAGE_PAGE (Generic Desktop)
	0x09, 0x36,                    //   USAGE (Slider)
	0x75, 0x08,                    //   REPORT_SIZE (8)
	0x95, 0x01,                    //   REPORT_COUNT (1)
	0x81, 0x02,                    //   INPUT (Data,Var,Abs)
	0x05, 0x02,                    //   USAGE_PAGE (Simulation Controls)
	0x09, 0xc5,                    //   USAGE (Brake)
	0x09, 0xbb,                    //   USAGE (Throttle)
	0x75, 0x08,                    //   REPORT_SIZE (8)
	0x95, 0x02,                    //   REPORT_COUNT (2)
	0x81, 0x02,                    //   INPUT (Data,Var,Abs)
	0x09, 0xc2,                    //   USAGE (Weapons Select)
	0x15, 0x00,                    //   LOGICAL_MINIMUM (0)
	0x26, 0xff, 0x00,              //   LOGICAL_MAXIMUM (255)
	0x75, 0x08,                    //   REPORT_SIZE (8)
	0x95, 0x01,                    //   REPORT_COUNT (1)
	0x81, 0x02,                    //   INPUT (Data,Var,Abs)
	0x09, 0xc7,                    //   USAGE (Shifter)
	0x15, 0x80,                    //   LOGICAL_MINIMUM (-128)
	0x25, 0x7f,                    //   LOGICAL_MAXIMUM (127)
	0x81, 0x02,                    //   INPUT (Data,Var,Abs)
	0xc0                           // END_COLLECTION
};



//
// This is the default HID descriptor returned by the mini driver
// in response to IOCTL_HID_GET_DEVICE_DESCRIPTOR. The size
// of report descriptor is currently the size of G_DefaultReportDescriptor.
//
CONST HID_DESCRIPTOR G_DefaultHidDescriptor = {
    0x09,   // length of HID descriptor
    0x21,   // descriptor type == HID  0x21
    0x0100, // hid spec release
    0x00,   // country code == Not Specified
    0x01,   // number of HID class descriptors
    { 0x22,   // descriptor type 
    sizeof(G_DefaultReportDescriptor) }  // total length of report descriptor
};

#endif // USE_HARDCODED_HID_REPORT_DESCRIPTOR

//
// Data generated by the Steel Battalion Controller
//
// == Buttons order ==
//
// Buttons0:
// 0x01 RightJoyMainWeapon
// 0x02 RightJoyFire
// 0x04 RightJoyLockOn
// 0x08 Eject
// 0x10 CockpitHatch
// 0x20 Ignition
// 0x40 Start
// 0x80 MultiMonOpenClose
//
// Buttons 1
// 0x01 MultiMonMapZoomInOut
// 0x02 MultiMonModeSelect
// 0x04 MultiMonSubMonitor
// 0x08 MainMonZoomIn
// 0x10 MainMonZoomOut
// 0x20 FunctionFSS
// 0x40 FunctionManipulator
// 0x80 FunctionLineColorChange
//
// Buttons 2
// 0x01 Washing
// 0x02 Extinguisher
// 0x04 Chaff
// 0x08 FunctionTankDetach
// 0x10 FunctionOverride
// 0x20 FunctionNightScope
// 0x40 FunctionF1
// 0x80 FunctionF2
//
// Buttons 3
// 0x01 FunctionF3
// 0x02 WeaponCtrlMain
// 0x04 WeaponCtrlSub
// 0x08 WeaponCtrlMagazineChange
// 0x10 Comm1
// 0x20 Comm2
// 0x40 Comm3
// 0x80 Comm4 
//
// Buttons 4
// 0x01 Comm5
// 0x02 LeftJoySightChange
// 0x04 ToggleFilterControl
// 0x08 ToggleOxygenSupply
// 0x10 ToggleFuelFlowRate
// 0x20 ToggleBufferMaterial
// 0x40 ToggleVTLocation
//
typedef struct _SBC_INPUT_DATA
{
	BYTE	_pad0;		
	BYTE	_pad1;		
	BYTE	Buttons0;
	BYTE	Buttons1;
	BYTE	Buttons2;
	BYTE	Buttons3;
	BYTE	Buttons4;
	BYTE	_pad2;
	USHORT	AimX;
	USHORT	AimY;
	SHORT	Rotation;
	SHORT	SightX;
	SHORT	SightY;
	USHORT	Clutch;
	USHORT	Brake;
	USHORT	Throttle;
	BYTE	Tuner;
	CHAR	Gear;
} SBC_INPUT_DATA, *PSBC_INPUT_DATA;

//
// HID Report Data
//
#include <pshpack1.h>
typedef struct _HIDFX2_INPUT_REPORT 
{
	BYTE Buttons0;
	BYTE Buttons1;
	BYTE Buttons2;
	BYTE Buttons3;
	BYTE Buttons4;
	BYTE AimX;
	BYTE AimY;
	BYTE Rotation;
	BYTE SightX;
	BYTE SightY;
	BYTE Clutch;
	BYTE Brake;
	BYTE Throttle;
	BYTE Tuner;
	CHAR Gear;
} HIDFX2_INPUT_REPORT, *PHIDFX2_INPUT_REPORT;
#include <poppack.h>

typedef struct _DEVICE_EXTENSION
{
    // WDF handles for USB Target 
    WDFUSBDEVICE      UsbDevice;
    WDFUSBINTERFACE   UsbInterface;
    WDFUSBPIPE        InterruptPipe;

    // Device descriptor for the USB device
    WDFMEMORY DeviceDescriptor;
    
    // WDF Queue for read IOCTLs from hidclass that get satisfied from 
    // USB interrupt endpoint
    WDFQUEUE   InterruptMsgQueue;
} DEVICE_EXTENSION, * PDEVICE_EXTENSION;

WDF_DECLARE_CONTEXT_TYPE_WITH_NAME(DEVICE_EXTENSION, GetDeviceContext)

//
// driver routine declarations
//
// This type of function declaration is for Prefast for drivers. 
// Because this declaration specifies the function type, PREfast for Drivers
// does not need to infer the type or to report an inference. The declaration
// also prevents PREfast for Drivers from misinterpreting the function type 
// and applying inappropriate rules to the function. For example, PREfast for
// Drivers would not apply rules for completion routines to functions of type
// DRIVER_CANCEL. The preferred way to avoid Warning 28101 is to declare the
// function type explicitly. In the following example, the DriverEntry function
// is declared to be of type DRIVER_INITIALIZE.
//
DRIVER_INITIALIZE DriverEntry;
EVT_WDF_DRIVER_DEVICE_ADD HidSteelBattalionEvtDeviceAdd;
EVT_WDF_IO_QUEUE_IO_INTERNAL_DEVICE_CONTROL HidSteelBattleEvtInternalDeviceControl;

NTSTATUS HidSteelBattalionGetHidDescriptor(IN WDFDEVICE Device, IN WDFREQUEST Request);
NTSTATUS HidSteelBattalionGetReportDescriptor(IN WDFDEVICE Device, IN WDFREQUEST Request);
NTSTATUS HidSteelBattalionGetDeviceAttributes(IN WDFREQUEST Request);

EVT_WDF_DEVICE_PREPARE_HARDWARE HidSteelBattalionEvtDevicePrepareHardware;
EVT_WDF_DEVICE_D0_ENTRY HidSteelBattalionEvtDeviceD0Entry;
EVT_WDF_DEVICE_D0_EXIT HidSteelBattalionEvtDeviceD0Exit;

PCHAR DbgDevicePowerString(IN WDF_POWER_DEVICE_STATE Type);
NTSTATUS HidSteelBattalionConfigContReaderForInterruptEndPoint(PDEVICE_EXTENSION DeviceContext);

EVT_WDF_USB_READER_COMPLETION_ROUTINE HidSteelBattalionEvtUsbInterruptPipeReadComplete;
EVT_WDF_OBJECT_CONTEXT_CLEANUP HidSteelBattalionEvtDriverContextCleanup;

PCHAR DbgHidInternalIoctlString(IN ULONG IoControlCode);
NTSTATUS HidSteelBattalionSendIdleNotification(IN WDFREQUEST Request);

USBD_STATUS HidSteelBattalionValidateConfigurationDescriptor(IN PUSB_CONFIGURATION_DESCRIPTOR ConfigDesc, IN ULONG BufferLength, _Inout_ PUCHAR *Offset);

#endif   //_HIDUSBFX2_H_
